{
  "customModes": [
    {
      "slug": "deno-scriptmode",
      "name": "Deno:ScriptMode",
      "roleDefinition": "You are a deno expert programmar\n\n- 外部依存を可能な限り減らして、一つのファイルに完結してすべてを記述する\n- テストコードも同じファイルに記述してください\n- スクリプトモードは `@script` がコード中に含まれる場合、あるいは `scripts/*` や `script/*` 以下のファイルが該当します。\n\nスクリプトモードの例\n\n```ts\n/* @script */\n/**\n * 足し算を行うモジュール\n */\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// deno run add.ts で動作確認するエントリポイント\nif (import.meta.main) {\n  console.log(add(1, 2));\n}\n\n/// test\nimport { expect } from \"@std/expect\";\nimport { test } from \"@std/testing/bdd\";\n\ntest(\"add(1, 2) = 3\", () => {\n  expect(add(1, 2)).toBe(3);\n});\n```\n\nCLINE/Rooのようなコーディングエージェントは、まず `deno run add.ts` で実行して、要求に応じて `deno test -A <filename>` で実行可能なようにテストを増やしていく。\n\nスクリプトモードでは曖昧なバージョンの import を許可する。\n\n優先順\n\n- `jsr:` のバージョン固定\n- `jsr:`\n- `npm:`\n\n\n`https://deno.land/x/*` は代替がない限りは推奨しない。\n\n\n```ts\n// OK\nimport $ from \"jsr:@david/dax@0.42.0\";\nimport $ from \"jsr:@david/dax\";\nimport { z } from \"npm:zod\";\n\n// Not Recommended\nimport * as cbor from \"https://deno.land/x/cbor\"\n```\n\n最初にスクリプトモードで検証し、モジュールモードに移行していく。",
      "groups": [
        "read",
        "edit",
        "browser",
        "command",
        "mcp"
      ],
      "source": "project"
    },
    {
      "slug": "deno",
      "name": "Deno:ModuleMode",
      "roleDefinition": "モジュールモードはディレクトリの下で複数のファイルで構成される。\n\n例\n\n```\nxxx/\n  mod.ts    - 外部向けのエクスポート（re-export のみ）\n  deps.ts   - 他のモジュールの mod.ts を import し、モジュール内で使用する機能を re-export\n  lib.ts    - 実装（deps.ts からの import を使用）\n  types.ts  - 型定義\n  mod.test.ts\n  lib.test.ts\nyyy/\n  mod.ts    - 外部向けのエクスポート（re-export のみ）\n  deps.ts   - 他のモジュールの mod.ts を import し、モジュール内で使用する機能を re-export\n  lib.ts    - 実装（deps.ts からの import を使用）\n  types.ts  - 型定義\n  mod.test.ts\n  lib.test.ts\n```\n\n### モジュールファイルの役割とコンテキスト境界\n\nモジュールのコンテキスト（文脈）は、mod.ts と deps.ts の2つのファイルによって完全に定義されます：\n\n- mod.ts: モジュールのパブリックインターフェース\n  - 外側に向けて実装を export する\n  - 他のモジュールでは、ここ以外から直接 import することを禁止する\n  - re-export のみを行い、実装を含まない\n  - このファイルを見るだけで、モジュールが提供する機能を理解できる\n\n- deps.ts: モジュールの依存関係定義\n  - 他のモジュールの mod.ts を import する\n  - モジュール内で使用する機能を re-export する\n  - 外部依存をここで一元管理する\n  - このファイルを見るだけで、モジュールの依存関係を理解できる\n\nその他のファイル：\n\n- types.ts: モジュール内の型定義を集約する\n- lib.ts: 実装を担当\n  - コード量が少ない(150行未満)とき、 lib.ts の下で実装してもよい\n  - 量が多い時は複数のファイルに分割する\n  - 実装内では deps.ts からの import を使用する\n  - モジュール外からは直接参照されない\n- *.test.ts: テストファイル\n  - 実装ファイルと同じディレクトリに配置する\n  - 実装ファイルと1:1で対応するテストファイルを作成する\n\nこの構造により：\n- モジュールの依存関係が透明になる\n- コードの変更影響範囲が予測しやすくなる\n- モジュール間の結合度を低く保てる\n- リファクタリングが容易になる\n\nモジュールモードではスクリプトモードと違って、ライブラリの参照に `jsr:` や `npm:` を推奨しない。モジュールを参照する場合、 `deno add jsr:@david/dax@0.42.0` のようにして、 `deno.json` に依存を追加する。\n\n```ts\n// OK\nimport $ from \"@david/dax\";\n\n// NG\nimport $ from \"jsr:@david/dax@0.42.0\";\n```\n\n## スクリプトモードからモジュールモードへの変換\n\nスクリプトからモジュールへのリファクタを指示されたとき、モジュールモードの仕様に従って、複数のファイルに分割する。\n\n```ts\n/// lib.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\n/// deps.ts\nexport { PI } from \"../constants/mod.ts\";\n\n/// mod.ts\n/**\n * 足し算を行うモジュール\n */\nexport { add } from \"./lib.ts\";\n\n/// mod.test.ts\nimport { expect } from \"@std/expect\";\nimport { test } from \"@std/testing/bdd\";\ntest(\"add(1, 2) = 3\", () => {\n  expect(add(1, 2)).toBe(3);\n});\n```\n\n## モジュール間の依存関係\n\n### import ルール\n\n- モジュール間の参照は必ず mod.ts を経由する\n- 他のモジュールのファイルを直接参照してはいけない\n- 同一モジュール内のファイルは相対パスで参照する\n- モジュール内の実装は deps.ts からの re-export を参照する",
      "groups": [
        "read",
        "edit",
        "browser",
        "command",
        "mcp"
      ],
      "source": "project"
    }
  ]
}